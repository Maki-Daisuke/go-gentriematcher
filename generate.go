package triematcher

import (
	"fmt"
	"io"
	"regexp"
	"text/template"
)

var reId = regexp.MustCompile(`^[0-9a-zA-Z_]+$`)

func GenerateMatcher(w io.Writer, tag_name string, signatures []string) error {
	if len(signatures) < 1 {
		return fmt.Errorf("GenerateMatch requires at least one string to make trie tree")
	}
	if tag_name != "" && !reId.MatchString(tag_name) {
		return fmt.Errorf(`GenerateMatcher: tag name must be an identifier, but "%s" is not`, tag_name)
	}
	m := initMap(signatures)
	allowSubmatch(m)
	return generateMatcherFromState(w, tag_name, m)
}

var templateFile = template.Must(template.New("file").Parse(`
// DO NOT EDIT!
// Code generated by go-triematcher <https://github.com/Maki-Daisuke/go-triematcher>
// DO NOT EDIT!

func Match{{ .TagName }}String(str string) bool {
  return Match{{ .TagName}}(([]byte)(str))
}

func Match{{ .TagName }}(bytes []byte) bool {
  defer func(){
    recover() // Must be "index out of range" error for string.
              // Ignore and return false.
  }()

  i := 0

{{ $start := .Start }}
  STATE_{{ $start.Id }}:
{{ if .IsGoal }}
    return true
{{ else }}
    switch bytes[i] {
  {{ range $key, $next := $start.Nexts }}
    case {{ printf "%q" $key }}:
      i++
      goto STATE_{{ $next.Id }}
  {{ end }}
    default:
      i++
      goto STATE_{{ $start.Id }}
    }
{{ end }}

{{ range .States }}
  STATE_{{ .Id }}:
  {{ if .IsGoal }}
      return true
  {{ else }}
    switch bytes[i] {
    {{ range $key, $next := .Nexts }}
    case {{ printf "%q" $key }}:
      i++
      goto STATE_{{ $next.Id }}
    {{ end }}
    default:
      goto STATE_{{ $start.Id }}
    }
  {{ end }}
{{ end }}
}
`))

func generateMatcherFromState(w io.Writer, tag_name string, st *state) error {
	states := listStates(st)
	err := templateFile.Execute(w, map[string]interface{}{
		"TagName": tag_name,
		"Start":   states[0],
		"States":  states[1:],
	})
	if err != nil {
		return err
	} else {
		return nil
	}
}

// Unlike allStates, this does not traverse goal state.
func listStates(start *state) []*state {
	marked := map[int]bool{}
	states := []*state{}

	var traverse func(*state)
	traverse = func(s *state) {
		if marked[s.Id] {
			return
		}
		states = append(states, s)
		marked[s.Id] = true
		if s.IsGoal {
			return
		}
		for _, next := range s.Nexts {
			traverse(next)
		}
	}
	traverse(start)

	return states
}
