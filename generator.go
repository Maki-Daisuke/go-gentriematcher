package triegun

import (
	"errors"
	"fmt"
	"io"
	"os"
	"regexp"
)
import "text/template"

var ErrEmpty = errors.New("triegun can't construct trie with empty string set")

type Plant struct {
	PkgName        string
	TagName        string
	DisableMatcher bool
	DisablePrefix  bool
	words          []string
}

func New() *Plant {
	return &Plant{
		PkgName: "main",
		words:   make([]string, 0),
	}
}

func (p *Plant) AddBytes(bytes ...[]byte) {
	for _, b := range bytes {
		p.words = append(p.words, string(b))
	}
}

func (p *Plant) AddString(strs ...string) {
	for _, s := range strs {
		p.words = append(p.words, s)
	}
}

func (p *Plant) GenFile(file string) (err error) {
	out, err := os.OpenFile(file, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		return err
	}
	defer func() {
		out.Close()
		if e := recover(); e != nil {
			var ok bool
			if err, ok = e.(error); !ok {
				panic(e)
			}
		}
		if err != nil {
			os.Remove(file)
		}
	}()
	err = p.Gen(out)
	return
}

var reId = regexp.MustCompile(`^[0-9a-zA-Z_]+$`)

func (p *Plant) Gen(w io.Writer) error {
	if len(p.words) < 1 {
		return ErrEmpty
	}
	if !reId.MatchString(p.PkgName) {
		return fmt.Errorf(`package name must be an identifier, but "%s" is not`, p.PkgName)
	}
	if p.TagName != "" && !reId.MatchString(p.TagName) {
		return fmt.Errorf(`tag name must be an identifier, but "%s" is not`, p.TagName)
	}
	dfa := newDFAFromStrings(p.words)
	if err := p.preamble(w); err != nil {
		return err
	}
	if !p.DisablePrefix {
		if err := p.genHasPrefix(w, dfa); err != nil {
			return err
		}
	}
	if !p.DisableMatcher {
		if err := p.genMatcher(w, dfa); err != nil {
			return err
		}
	}
	return nil
}

func (g *Plant) preamble(w io.Writer) error {
	return tmplPreabmle.Execute(w, g)
}

var tmplPreabmle = template.Must(template.New("preamble").Parse(`
// DO NOT EDIT!
// Code generated by go-triegun <https://github.com/Maki-Daisuke/go-triegun>
// DO NOT EDIT!
package {{ .PkgName }}

import "unsafe"
`))
